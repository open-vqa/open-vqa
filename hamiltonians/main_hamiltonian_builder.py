{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "13b5356d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import cirq\n",
    "from qiskit.quantum_info import Operator, Pauli, SparsePauliOp\n",
    "from qat.core import Observable, Term\n",
    "from circuit_type.circuit import CircuitType\n",
    "\n",
    "class HamiltonianBuilder:\n",
    "    def __init__(self, num_qubits, terms, use_sparse_pauli_op=True):\n",
    "        \"\"\"\n",
    "        Parameters:\n",
    "            num_qubits (int): Number of qubits.\n",
    "            terms (list): List of terms (tuple or dict). Example: (-0.5, 'IXZ')\n",
    "            use_sparse_pauli_op (bool): If True, use SparsePauliOp for Qiskit Hamiltonian.\n",
    "        \"\"\"\n",
    "        self.num_qubits = num_qubits\n",
    "        self.use_sparse_pauli_op = use_sparse_pauli_op\n",
    "        self.terms = []\n",
    "        for term in terms:\n",
    "            if isinstance(term, dict):\n",
    "                coeff = term.get('coefficient')\n",
    "                pauli = term.get('pauli')\n",
    "            elif isinstance(term, (tuple, list)):\n",
    "                coeff, pauli = term\n",
    "            else:\n",
    "                raise ValueError(\"Each term must be a tuple or dict.\")\n",
    "\n",
    "            if len(pauli) != num_qubits:\n",
    "                raise ValueError(f\"Pauli string '{pauli}' length does not equal num_qubits={num_qubits}.\")\n",
    "\n",
    "            self.terms.append({'coefficient': coeff, 'pauli': pauli})\n",
    "\n",
    "    def get_qiskit_hamiltonian(self):\n",
    "        \"\"\"\n",
    "        Returns the Hamiltonian in Qiskit's format (SparsePauliOp or Operator(Pauli)).\n",
    "        \"\"\"\n",
    "        if self.use_sparse_pauli_op:\n",
    "            # Build as SparsePauliOp\n",
    "            built_terms = [(term['pauli'], term['coefficient']) for term in self.terms]\n",
    "            return SparsePauliOp.from_list(built_terms)\n",
    "        else:\n",
    "            # Build as sum of Operator(Pauli)\n",
    "            hamiltonian = None\n",
    "            for term in self.terms:\n",
    "                coeff = term['coefficient']\n",
    "                pauli_str = term['pauli']\n",
    "                term_op = coeff * Operator(Pauli(pauli_str))\n",
    "                if hamiltonian is None:\n",
    "                    hamiltonian = term_op\n",
    "                else:\n",
    "                    hamiltonian += term_op\n",
    "            return hamiltonian\n",
    "\n",
    "    def get_qlm_observable(self) -> Observable:\n",
    "        \"\"\"\n",
    "        Returns the Hamiltonian as a QLM Observable object (qat.core).\n",
    "        \"\"\"\n",
    "        pauli_terms = []\n",
    "        for term in self.terms:\n",
    "            coeff = term['coefficient']\n",
    "            pauli_str = term['pauli']\n",
    "            qubit_indices = list(range(self.num_qubits))\n",
    "            pauli_terms.append(Term(coeff, pauli_str, qubit_indices))\n",
    "        return Observable(self.num_qubits, pauli_terms=pauli_terms, constant_coeff=0)\n",
    "\n",
    "    def get_cirq_observable(self):\n",
    "        \"\"\"\n",
    "        Returns the Hamiltonian as a Cirq PauliSum.\n",
    "        \"\"\"\n",
    "        qubits = [cirq.LineQubit(i) for i in range(self.num_qubits)]\n",
    "        pauli_sum = cirq.PauliSum()\n",
    "\n",
    "        for term in self.terms:\n",
    "            coeff = term['coefficient']\n",
    "            pauli_str = term['pauli']\n",
    "            ps_dict = {}\n",
    "\n",
    "            for i, letter in enumerate(pauli_str):\n",
    "                if letter == 'I':\n",
    "                    continue\n",
    "                elif letter == 'X':\n",
    "                    ps_dict[qubits[i]] = cirq.X\n",
    "                elif letter == 'Y':\n",
    "                    ps_dict[qubits[i]] = cirq.Y\n",
    "                elif letter == 'Z':\n",
    "                    ps_dict[qubits[i]] = cirq.Z\n",
    "                else:\n",
    "                    raise ValueError(f\"Unsupported Pauli letter: '{letter}' in term '{pauli_str}'\")\n",
    "\n",
    "            if ps_dict:\n",
    "                pauli_string = cirq.PauliString(ps_dict, coefficient=coeff)\n",
    "                pauli_sum += pauli_string\n",
    "\n",
    "        return pauli_sum\n",
    "\n",
    "    def get_hamiltonian(self, circuit_type: CircuitType):\n",
    "        \"\"\"\n",
    "        Dispatcher to get Hamiltonian in the requested framework.\n",
    "        \"\"\"\n",
    "        if circuit_type == CircuitType.QISKIT:\n",
    "            return self.get_qiskit_hamiltonian()\n",
    "        elif circuit_type == CircuitType.QLM:\n",
    "            return self.get_qlm_observable()\n",
    "        elif circuit_type == CircuitType.CIRQ:\n",
    "            return self.get_cirq_observable()\n",
    "        else:\n",
    "            raise ValueError(f\"Unsupported circuit type: {circuit_type}\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python (cwq)",
   "language": "python",
   "name": "cwq"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
